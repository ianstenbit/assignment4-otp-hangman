defmodule Hangman.Game do

  @moduledoc """

  This is the backend for a Hangman game. It manages the game state.
  Clients make moves, and this code validates them and reports back
  the updated state.

  We have a well-defined API that is used by client code

  * `game = Hangman.Game.new_game`

    Set up the state for a new game, and return that state. The client
    applications will pass this state back to your code in all the
    subsequent API calls.

    The state that's returned will at a minimum contain the word to be
    guessed.

    As an aid to testing, there's a second form of this function:

    `game = Hangman.Game.new_game(word)`

    This forces `word` to be this game's hidden word.


  * `len = Hangman.Game.word_length(game)`

    Return the length of the current word.

  * `list = letters_used_so_far(game)`

    The letters that have been guessed so far, returned as a list of
    single character strings. (This includes both correct and
    incorrect guessed.

  * `count = turns_left(game)`

    Returns the number of turns remaining before the game is over.
    For our purposes, a game starts with a generous 10 turns. Each
    _incorrect_ guess decrements this.

  * `word = word_as_string(game, reveal \\ false)`

     Returns the word to be guessed. If the optional second argument is
     false, then any unguessed letters will be returned as underscores.
     If it is true, then the word will be returned complete, showing
     all letters. Letters and underscores are separated by spaces.

  *  `{game, status, guess} = make_move(game, guess)`

     Accept a guess. Return a three element tuple containing the updated
     game state, an atom giving the status at the end of the move, and
     the letter that was guessed.

     The status can be:

     * `:won` — the guess correct and completed the game. The client won

     * `:lost` — the guess was incorrect and the client has run out of
        turns. The game has been lost.

     * `:good_guess` — the guess occurs one or more times in the word

     * `:bad_guess` — the word does not contain the guess. The number
       of turns left has been reduced by 1

## Example of use

Here's this module being exercised from an iex session:

    iex(1)> alias Hangman.Game, as: G
    Hangman.Game

    iex(2)> game = G.new_game
    . . .

    iex(3)> G.word_length(game)
    6

    iex(4)> G.word_as_string_string(game)
    "_ _ _ _ _ _"

    iex(5)> { game, state, guess } = G.make_move(game, "e")
    . . .

    iex(6)> state
    :good_guess

    iex(7)> G.word_as_string(game)
    "_ _ e e _ e"

    iex(8)> { game, state, guess } = G.make_move(game, "q")
    . . .

    iex(9)> state
    :bad_guess

    iex(10)> { game, state, guess } = G.make_move(game, "r")
    . . .

    iex(11)> state
    :good_guess

    iex(12)> G.word_as_string(game)
    "_ r e e _ e"

    iex(13)> { game, state, guess } = G.make_move(game, "b")
    . . .
    iex(14)> state                                          
    :bad_guess

    iex(15)> { game, state, guess } = G.make_move(game, "f")
    . . .

    iex(16)> state
    :good_guess

    iex(17)> G.word_as_string(game)
    "f r e e _ e"

    iex(18)> { game, state, guess } = G.make_move(game, "z")
    . . .

    iex(19)> state
    :won

    iex(20)> G.word_as_string(game)
    "f r e e z e"


  """



  @type state :: map
  @type ch    :: binary
  @type optional_ch :: ch | nil

  @doc """
  Run a game of Hangman with our user. Use the dictionary to
  find a random word, and then let the user make guesses.

  If a paramter is supplied, it is used instead of a random word.
  This is used by the unit tests.
  """

  @spec new_game(binary) :: state
  def new_game(word \\ Hangman.Dictionary.random_word) do
    %{
      word:        String.codepoints(word) |> Enum.map(&{&1, false}),
      turns_left:  10,
      guessed:     MapSet.new,
    }
  end


  @doc """
  `{game, status, guess} = make_move(game, guess)`

  Accept a guess. Return a three element tuple containing the updated
  game state, an atom giving the status at the end of the move, and
  the letter that was guessed.

  The status can be:

  * `:won` — the guess correct and completed the game. The client won

  * `:lost` — the guess was incorrect and the client has run out of
     turns. The game has been lost.

  * `:good_guess` — the guess occurs one or more times in the word

  * `:bad_guess` — the word does not contain the guess. The number
     of turns left has been reduced by 1
  """

  @spec make_move(state, ch) :: { state, atom, optional_ch }
  def make_move(state = %{turns_left: 0}, _) do
    { state, :lost, nil }
  end

  def make_move(state, guess) do
    { state, guess_is_correct } = score_move(state, guess)
    %{ state | guessed: MapSet.put(state.guessed, guess) }
    |> return_result_of_move(guess_is_correct, guess)
  end

  @doc """
  `len = Hangman.Game.word_length(game)`

  Return the length of the current word.
  """

  @spec word_length(state) :: integer
  def word_length(%{ word: word }) do
    length(word)
  end

  @doc """
  `list = letters_used_so_far(game)`

  The letters that have been guessed so far, returned as a list of
  single character strings. (This includes both correct and
  incorrect guessed.
  """

  @spec letters_used_so_far(state) :: [ binary ]
  def letters_used_so_far(game) do
    game.guessed |> MapSet.to_list
  end

  @doc """
  `count = turns_left(game)`

  Returns the number of turns remaining before the game is over.
  For our purposes, a game starts with a generous 10 turns. Each
  _incorrect_ guess decrements this.
  """

  @spec turns_left(state) :: integer
  def turns_left(game) do
    game.turns_left
  end

  @doc """
  `word = word_as_string(game, reveal \\ false)`

  Returns the word to be guessed. If the optional second argument is
  false, then any unguessed letters will be returned as underscores.
  If it is true, then the word will be returned complete, showing
  all letters. Letters and underscores are separated by spaces.
  """

  @spec word_as_string(state, boolean) :: binary
  def word_as_string(state, reveal \\ false) do
    placeholder = fn {ch, known} ->
      cond do
        known || reveal -> ch
        true            -> "_"
      end
    end
    state.word |> Enum.map(placeholder) |> Enum.join(" ")
  end

  ###########################
  # end of public interface #
  ###########################

  defp return_result_of_move(state, correct, guess) do
    cond do
      player_won?(state) ->
        { state, :won, nil }

      correct ->
        { state, :good_guess, guess }

      state.turns_left > 1 ->
        state = %{ state | turns_left: state.turns_left - 1 }
        { state, :bad_guess, guess }

      true ->
        state = %{ state | turns_left: state.turns_left - 1 }
        { state, :lost, nil }
    end
  end

  defp score_move(state, guess) do
    if word_contains_guess?(state.word, guess) do
      new_word = Enum.map(state.word, fn
                           { ^guess, _ } -> { guess, true }
                           other         -> other
                          end)
      { %{ state | word: new_word }, true }
    else
      { state, false }
    end
  end

  defp word_contains_guess?(word, guess) do
    Enum.any?(word, fn { ch, _ } -> ch == guess end)
  end

  defp player_won?(%{word: word}) do
    Enum.all?(word, fn {_ch, ok } -> ok end)
  end
end
